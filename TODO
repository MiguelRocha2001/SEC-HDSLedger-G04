- Maybe, check if are processes interatcing with the system, that are not registered as expected processes;
- Ask lab professor on how to do good testing.
- How is the comunication made betrween client and server? UDP?
- Do we need to add security between client - server?: just authentication with assymetric keys.
- What are "upcalls" in the context of the project?
- What kind of components do we need to test? All the link layer? Or just authentication?
- Should we use perfect links or even more complex abstractions as Reliable broadcast, etc: Just add digital signatures to every message and justify that we just want integrity and authentication on every message;

- We could use digital certificates and then distribute accordingly;
- Client app has a command line interface. The library hides the complexity of comunicating with the blockchain;
- Implement round change in blockchain;
- Blockchain is array of strings;
- The library catches the request and triggers the concensus;
- Main challenge: what can go bad on every step of the process.
- The library will never atack the request. Behaves well; Blockchain can only have f byzantine prozesses. The network is unreliable. Therer are already abstractions implemented to fight this. What should the link garantee? What at does it already garantee? WHat should we implement? UDP simulates fair loss;
- Think of how to maintain the blockchain consistent having in mind byzantine processes: We could have a process not the leader faking being the leader. Think about that. We need to consider that leaders can by byzantine. Thats wy we use round changes. 
Only the leader can trigger consensus. What if the leader is byzantine?
If the leader is byzantine, receives the request from the client and changes the value on porpuse? How to solve this?
- Digital signature is way havier vs MACs. Thjere are situations when we may not need all digitaal signatures garantee properties.
- If we want to use systetric keys, we should distribute them and not assume they are already distributed. Make key exchange first. It is expensive but if the blockchain runs infinitly, it will prevail over the overhead of exchanging the keys. But theory teacher said theres no need to use symetric encription and we could just use assymetric encription for everyting;
- Dont make tests for normal functioning of the system that was already provided and it works; 
- Do tests for byzantine cases: the blockchain have byzantine members. Include the maximum byzantine cases in tests. A client byzantine is few cases. The members of tthe blockchain being byzantine are much more cases to test. 
- Understand very well how the link layer is being used on the consensus service. How are messages created, etc.
- Understand very well the normal case and only then, go to round changes.
- Make specific tests for STEP_2.
- In the report, what can go wrong? thats the important part. What can go right is not so important. For example: we are using signatures here because its important to mantain integrity.
- Actually, we can just use digital signatures for everything, and not worry about performance issues.